"use client"

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query"
import { createClient } from "@/utils/supabase/client"
import { Summary } from "@/types"
import { toast } from "sonner"

const supabase = createClient()

export const useSummarize = () => {
  const queryClient = useQueryClient()

  // Get summary for a specific note
  const getSummary = async (noteId: string): Promise<Summary | null> => {
    const { data, error } = await supabase
      .from("summaries")
      .select("*")
      .eq("note_id", noteId)
      .maybeSingle()

    if (error) {
      toast.error(error.message)
      throw error
    }

    return data
  }

  // Generate a summary using Gemini API
  const generateSummary = async (text: string): Promise<string> => {
    try {
      const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY || ""
      
      if (!apiKey) {
        toast.error("API key is not configured")
        throw new Error("Gemini API key is not configured")
      }

      console.log("Generating summary using Gemini API...")
      
      // If the API is not working, we can use a fallback approach for demo purposes
      // This simulates an AI summary without calling an external API
      // Remove this in production and use the actual API call below
      const fallbackSummary = `Summary of the provided content: 
      
${text.slice(0, 100)}...
      
This is a simplified summary of the content provided. In a real implementation, this would be generated by the Gemini API.`;
      
      // Return the fallback summary for development/testing
      // return fallbackSummary;
      
      
      const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: `Please summarize the following text in a concise way, highlighting the main points:\n\n${text}`
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.2,
            maxOutputTokens: 500,
            topP: 0.8,
            topK: 40
          }
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Gemini API error:", errorData);
        throw new Error(errorData.error?.message || "Failed to generate summary");
      }

      const data = await response.json();
      // Extract the summary from Gemini's response format
      const summaryText = data.candidates[0].content.parts[0].text;
      return summaryText;
      
    } catch (error: any) {
      console.error("Summarization error:", error)
      toast.error(error.message || "Failed to generate summary")
      throw error
    }
  }

  // Create or update a summary for a note
  const createSummary = async ({ noteId, content }: { noteId: string; content: string }): Promise<Summary> => {
    try {
      // First check if a summary already exists for this note
      const { data: existingSummary } = await supabase
        .from("summaries")
        .select("id")
        .eq("note_id", noteId)
        .maybeSingle();
      
      let result;
      
      if (existingSummary) {
        // Update existing summary
        const { data, error } = await supabase
          .from("summaries")
          .update({ content })
          .eq("id", existingSummary.id)
          .select()
          .single();
          
        if (error) throw error;
        result = data;
        toast.success("Summary updated");
      } else {
        // Create new summary
        const summary = {
          note_id: noteId,
          content
        };
        
        const { data, error } = await supabase
          .from("summaries")
          .insert([summary])
          .select()
          .single();
          
        if (error) throw error;
        result = data;
        toast.success("Summary created");
      }
      
      return result;
    } catch (error: any) {
      console.error("Error saving summary:", error);
      toast.error(error.message || "Failed to save summary");
      throw error;
    }
  }

  // Delete a summary
  const deleteSummary = async (id: string): Promise<void> => {
    const { error } = await supabase
      .from("summaries")
      .delete()
      .eq("id", id)

    if (error) {
      toast.error(error.message)
      throw error
    }

    toast.success("Summary deleted")
  }

  // React Query hooks
  const useSummaryQuery = (noteId: string) => {
    return useQuery({
      queryKey: ["summaries", noteId],
      queryFn: () => getSummary(noteId),
      enabled: !!noteId,
    })
  }

  const useGenerateSummaryMutation = () => {
    return useMutation({
      mutationFn: generateSummary,
    })
  }

  const useCreateSummaryMutation = () => {
    return useMutation({
      mutationFn: createSummary,
      onSuccess: (data) => {
        queryClient.invalidateQueries({ queryKey: ["summaries", data.note_id] })
      },
    })
  }

  const useDeleteSummaryMutation = () => {
    return useMutation({
      mutationFn: deleteSummary,
      onSuccess: () => {
        // We'll need to pass the noteId externally to invalidate the correct query
      },
    })
  }

  return {
    useSummaryQuery,
    useGenerateSummaryMutation,
    useCreateSummaryMutation,
    useDeleteSummaryMutation,
  }
} 